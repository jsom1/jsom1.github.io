---
title: "Basic Pentesting: 1"
author: "Me"
date: "February 23, 2020"
output: html_document
---

# Basic Pentesting: 1

**Difficulty**: beginner\\
**Type** : boot2root\\
**Objective** : gain root access

**Lab configuration**

1. Download the box:\\
[https://www.vulnhub.com/entry/basic-pentesting-1,216/](https://www.vulnhub.com/entry/basic-pentesting-1,216/)

2. Download Kali Linux (if you don't have it already):\\
[https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/](https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/)

3. Import both VMs in VirtualBox. For each of them, go in settings -> network and select Host-only Adapter (the name should appear by default. If it does not, create one from the initial menu: File -> Host Network Manager -> create).
With this configuration, the VMs are isolated on a network.
It is also possible to set both VMs in bridged adapter, and add a second interface for the Kali machine with NAT (so that kali can access the internet).

## Before we begin: find the victim's IP address and verify we can communicate with it
{:style="color:DarkRed; font-size: 170%;"}

First, we turn on the 2 VMs. We can't connect to the target machine, because we don't know the credentials. The purpose will be to gain root access on this machine.

Sometimes, the IP address of the target is given on the start-up screen, but it is rarely the case. Let's look at our IP address :

<div class="img_container">
![ifconfig]({{https://jsom1.github.io/}}/_images/bpt1_ifconf.png){: height="300px" width = "300px"}
</div>

There are 2 interfaces, eth0 and lo (for local). Our IP address is 192.168.56.102, and the subnet mask is 255.255.255.0. The local IP address is always 127.0.0.1, it's a convention.

**What's a subnet mask, and how can we find our victim on the network ?**\\
As we saw, our subnet mask is 255.255.255.0. In binary, this can be written\\
11111111.11111111.11111111.00000000\\
because:\\
255 = 1\*2^7 +  1\*2^6 + 1\*2^5 + 1\*2^4 + 1\*2^3 + 1\*2^2 + 1\*2^1 + 1\*2^0\\
255 = 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1

A very important concept is that 1s and 0s cannot be mixed in the mask. Therefore, if we know the number of 1s in a mask, we know the **complement**. In our subnet mask, there are *24 bits up*. So, our IP address and the subnet mask can be written 192.168.56.102**/24** (24 is the complement). This is called CIDR (classless interdomain routing) notation. Without it, we would have to write 192.168.56.102/255.255.255.0.

**What does the mask tell us ?**\\
It gives some information on the network: it says how many bits (what portion) of the IP address belong to the network, and how many belong to the hosts. For example, the mask 255.255.255.0 applied to our IP address 192.168.56.102 tells that 192.168.56 represents the network portion of the address, and 102 is the host on this network.

**How many hosts can we have on a network ?**\\
There is a simple formula to answer this question: the number of hosts on a network = 2^(nb of 0s in the mask). There are 8 0s in our mask, so there are 2^8 = 256 potential hosts (in reality 254, because we remove the first and last addresses (gateway and broadcast). The last address of the range is always the broadcast one.

Finally, we can scan our network to find the target's IP address. To do so, we scan it from the first to the last address with the following command :

<div class="img_container">
![netdiscover]({{https://jsom1.github.io/}}/_images/bpt1_netdisc.png){: height="25px" width = "25px"}
</div>

which results in :

<div class="img_container">
![netdiscover result]({{https://jsom1.github.io/}}/_images/bpt1_netdiscres.png){: height="180px" width = "180px"}
</div>

The target's IP address is 192.168.56.105. To be sure, we can use nmap:

<div class="img_container">
![nmap]({{https://jsom1.github.io/}}/_images/bpt1_nmap.png){: height="400px" width = "400px"}
</div>

As we can see, 192.168.56.105 indeed is our target, because its mac address is VirtualBox. Now that we have our target, we can verify that we can communicate with it. To check this, we simply ping the target from Kali as follows:

<div class="img_container">
![ping]({{https://jsom1.github.io/}}/_images/bpt1_ping.png){: height="150px" width = "150px"}
</div>

The flag *-c* allows to specify how many packets we send (2 here). We have the confirmation to the machines can communicate, so we're ready to really start this box :) !


## 1. Scan the ports of the target
{:style="color:DarkRed; font-size: 170%;"}
There are a total of 65,535 possible TCP ports, and 65,535 possible UDP ports. Some ports are "reserved" for certain services, among which:
- port 21 for FTP (File Transfer Protocol)
- port 22 for SSH (Secure shell)
- port 23 for Telnet (Terminal Network)
- port 25 for SMTP (Simple Mail Transfer Protocol)
- port 80 for HTTP (Hypertext Transfer Protocol)
- ...

A scanner like nmap allows us to see what ports are open on the target, and what services are running.

<div class="img_container">
![nmap2]({{https://jsom1.github.io/}}/_images/bpt1_nmap2.png){: height="250px" width = "250px"}
</div>

The flag *-sV* specifies that we only want to scan open ports (to speed the process), and returns the services that are running as well as their version. Here, we see 3 open ports :
- 21 (TCP) with vsftpd 2.0.8 or later
- 22 (SSH) with OpenSSH 8.0p1 Ubuntu 6build1
- 80 (HTTP) with Apache httpd 2.4.41 (Ubuntu)

Later, we will look for potential vulnerabilities for the versions of the services running on those ports. Another useful information here is that the target is a Ubuntu machine. If this was not specified, we could try to detect the target's OS (this is called **banner grabbing**) in different ways. We could, for example, try to start a Telnet session with the victim on the port 80: obviously, this will not work since Telnet is on port 23, and port 80 is for HTTP. The target machine would send us an error message with information on its OS :

<div class="img_container">
![banner grabbing]({{https://jsom1.github.io/}}/_images/bpt1_bangrab.png){: height="360px" width = "360px"}
</div>

Knowing the OS is necessary, because some exploits are OS-specific.

## 2. Find a vulnerability
{:style="color:DarkRed; font-size: 170%;"}
