---
title: "Basic Pentesting: 1"
author: "Me"
date: "February 23, 2020"
output: html_document
---

# Basic Pentesting: 1

**Difficulty**: beginner\\
**Type** : boot2root\\
**Objective** : gain root access

**Lab configuration**

1. Download the box:\\
[https://www.vulnhub.com/entry/basic-pentesting-1,216/](https://www.vulnhub.com/entry/basic-pentesting-1,216/)

2. Download Kali Linux (if you don't have it already):\\
[https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/](https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/)

3. Import both VMs in VirtualBox. For each of them, go in settings -> network and select Host-only Adapter (the name should appear by default. If it does not, create one from the initial menu: File -> Host Network Manager -> create).
With this configuration, the VMs are isolated on a network.
It is also possible to set both VMs in bridged adapter, and add a second interface for the Kali machine with NAT (so that kali can access the internet).

## Before we begin: find the victim's IP address and verify we can communicate with it
{:style="color:DarkRed; font-size: 170%;"}

First, we turn on the 2 VMs. We can't connect to the target machine, because we don't know the credentials. The purpose will be to gain root access on this machine.

Sometimes, the IP address of the target is given on the start-up screen, but it is rarely the case. Let's look at our IP address :

<div class="img_container">
![ifconfig]({{https://jsom1.github.io/}}/_images/bpt1_ifconf.png){: height="300px" width = "300px"}
</div>

There are 2 interfaces, eth0 and lo (for local). Our IP address is 192.168.56.102, and the subnet mask is 255.255.255.0. The local IP address is always 127.0.0.1, it's a convention.

**What's a subnet mask, and how can we find our victim on the network ?**\\
As we saw, our subnet mask is 255.255.255.0. In binary, this can be written\\
11111111.11111111.11111111.00000000\\
because:\\
255 = 1\*2^7 +  1\*2^6 + 1\*2^5 + 1\*2^4 + 1\*2^3 + 1\*2^2 + 1\*2^1 + 1\*2^0\\
255 = 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1

A very important concept is that 1s and 0s cannot be mixed in the mask. Therefore, if we know the number of 1s in a mask, we know the **complement**. In our subnet mask, there are *24 bits up*. So, our IP address and the subnet mask can be written 192.168.56.102**/24** (24 is the complement). This is called CIDR (classless interdomain routing) notation. Without it, we would have to write 192.168.56.102/255.255.255.0.

**What does the mask tell us ?**\\
It gives some information on the network: it says how many bits (what portion) of the IP address belong to the network, and how many belong to the hosts. For example, the mask 255.255.255.0 applied to our IP address 192.168.56.102 tells that 192.168.56 represents the network portion of the address, and 102 is the host on this network.

**How many hosts can we have on a network ?**\\
There is a simple formula to answer this question: the number of hosts on a network = 2^(nb of 0s in the mask). There are 8 0s in our mask, so there are 2^8 = 256 potential hosts (in reality 254, because we remove the first and last addresses (gateway and broadcast). The last address of the range is always the broadcast one.

Finally, we can scan our network to find the target's IP address. To do so, we scan it from the first to the last address with the following command :

<div class="img_container">
![netdiscover]({{https://jsom1.github.io/}}/_images/bpt1_netdisc.png){: height="25px" width = "25px"}
</div>

which results in :

<div class="img_container">
![netdiscover result]({{https://jsom1.github.io/}}/_images/bpt1_netdiscres.png){: height="180px" width = "180px"}
</div>

The target's IP address is 192.168.56.106. To be sure, we can use nmap:

<div class="img_container">
![nmap]({{https://jsom1.github.io/}}/_images/bpt1_nmap.png){: height="400px" width = "400px"}
</div>

As we can see, 192.168.56.106 indeed is our target, because its mac address is VirtualBox. Now that we have our target, we can verify that we can communicate with it. To check this, we simply ping the target from Kali as follows:

<div class="img_container">
![ping]({{https://jsom1.github.io/}}/_images/bpt1_ping.png){: height="150px" width = "150px"}
</div>

The flag *-c* allows to specify how many packets we send (2 here). We have the confirmation to the machines can communicate, so we're ready to really start this box :) !


## 1. Scan the ports of the target
{:style="color:DarkRed; font-size: 170%;"}
There are a total of 65,535 possible TCP ports, and 65,535 possible UDP ports. Some ports are "reserved" for certain services, among which:
- port 21 for FTP (File Transfer Protocol)
- port 22 for SSH (Secure shell)
- port 23 for Telnet (Terminal Network)
- port 25 for SMTP (Simple Mail Transfer Protocol)
- port 80 for HTTP (Hypertext Transfer Protocol)
- ...

A scanner like nmap allows us to see what ports are open on the target, and what services are running.

<div class="img_container">
![nmap2]({{https://jsom1.github.io/}}/_images/bpt1_nmap2.png){: height="250px" width = "250px"}
</div>

The flag *-sV* specifies that we only want to scan open ports (to speed the process), and returns the services that are running as well as their version. Here, we see 3 open ports :
- 21 (TCP) with ProFTPD 1.3.3c
- 22 (SSH) with OpenSSH 7.2p2 Ubuntu 4ubuntu2.2
- 80 (HTTP) with Apache httpd 2.4.18 (Ubuntu)

Later, we will look for potential vulnerabilities for the versions of the services running on those ports. Another useful information here is that the target is a Ubuntu machine. If this was not specified, we could try to detect the target's OS (this is called **banner grabbing**) in different ways. We could, for example, try to start a Telnet session with the victim on the port 80: obviously, this will not work since Telnet is on port 23, and port 80 is for HTTP. The target machine would send us an error message with information on its OS :

<div class="img_container">
![banner grabbing]({{https://jsom1.github.io/}}/_images/bpt1_bangrab.png){: height="360px" width = "360px"}
</div>

Knowing the OS is necessary, because some exploits are OS-specific.

## 2. Find and exploit vulnerabilities
{:style="color:DarkRed; font-size: 170%;"}
Now, we will investigate the 3 open ports, starting with FTP.

**FTP**\\
FTP is a standard network protocol used for the transfer of computer files between a client and a server on a network. Users authenticate themselves with a username and a password. However, it is sometimes possible to connect **anonymously** (the server has to be configured to allow it). This is done to allow the public to connect to the server and access the files without identification.\\
We can connect anonymously with the login *anonymous* and any password (usually an email address, or the word *guest*). So, let's try this first:

<div class="img_container">
![anonymous FTP]({{https://jsom1.github.io/}}/_images/bpt1_ftpano.png){: height="250px" width = "250px"}
</div>

I tried different passwords, but couldn't get in... That's not a problem, we'll find another way in.

On the result of the nmap scan, we saw that the version of FTP is *ProFTPD 1.3.3c*. We could look for more information on the net (for example on [https://www.cvedetails.com/](https://www.cvedetails.com/)). However, let's look at Metasploit instead :

<div class="img_container">
![searchsploit]({{https://jsom1.github.io/}}/_images/bpt1_searchsploit.png){: height="220px" width = "220px"}
</div>

There are 2 modules for this vulnerability. Let's launch Metasploit with the following command:
~~~
msfconsole
~~~~
In Metasploit, the line starts with *msf5*. Now, we can search more information on the modules:

<div class="img_container">
![msf search]({{https://jsom1.github.io/}}/_images/bpt1_msfsearch.png){: height="250px" width = "250px"}
</div>

We see 6 different exploits. We could try some of these, but there's one that seems to be what we're looking for: the 4th one, *exploit/unix/ftp/proftpd_133c_backdoor*. It's rated excellent, it's the right version, and it's a backdoor command execution.\\
Let's launch this exploit and see what parameters it requires (with the *options* command):

<div class="img_container">
![exploit]({{https://jsom1.github.io/}}/_images/bpt1_exploit.png){: height="250px" width = "250px"}
</div>

The options show that there are 2 required parameters, RHOSTS and RPORT. RPORT is already set to 21, so we just have to complete RHOSTS. Also, we see that the target is automatic. So, let's set the RHOST parameter and launch the exploit !

<div class="img_container">
![exploit result]({{https://jsom1.github.io/}}/_images/bpt1_exploitres.png){: height="300px" width = "300px"}
</div>

It worked, and it opened a session for us. Who are we ?
~~~~
whoami
~~~~~
returns root. We did it! Then, we can look for interesting things with the usual commands *cd*, *ls*, ... We see that there is a wordpress instance and a user called *Marlinspike* - let's save it for later, it could be useful information.

**HTTP**\\
We also saw with nmap that there is a web server running. After successfuly connecting with FTP, we saw that it is a wordpress instance. Let's connect to it from Kali:

<div class="img_container">
![wordpress]({{https://jsom1.github.io/}}/_images/bpt1_wp.png){: height="180px" width = "180px"}
</div>

There is a page, but it doesn't seem to be working properly. We can try to manually find directories, such as */wp-admin* (the default login page for Wordpress - doesn't work here), but it's not easy. Instead, let's perform a **dictionnary attack** with *dirbuster*: it brute-forces directories and file names on web servers.

<div class="img_container">
![dirbuster]({{https://jsom1.github.io/}}/_images/bpt1_dirb1.png){: height="450px" width = "450px"}
</div>

<div class="img_container">
![dirbuster]({{https://jsom1.github.io/}}/_images/bpt1_dirb2.png){: height="450px" width = "450px"}
</div>

We see that dirbuster found 13 directories (not all of them are listed here). Let's have a loot at this *secret* directory:

<div class="img_container">
![secret directory]({{https://jsom1.github.io/}}/_images/bpt1_secret.png){: height="400px" width = "450px"}
</div>

The appareance is weird... If we scroll down the page, we see a *Log In* button. When we click on it, we get the following error message:

<div class="img_container">
![wp login error]({{https://jsom1.github.io/}}/_images/bpt1_wplogin.png){: height="400px" width = "450px"}
</div>

In fact, we can click anywhere, we get the same error message: "We can't connect to the server at vtcsec". It seems like there is a DNS problem. Since my Kali isn't connected to the internet, it doesn't find the link between the IP address and the server's name (can't see DNS information). However, we can manually add an entry for the server vtcsec in our hosts file. First, we open the file with nano, and then we add the server's IP and name:

~~~~
nano /etc/hosts
~~~~

<div class="img_container">
![hosts]({{https://jsom1.github.io/}}/_images/bpt1_hosts.png){: height="150px" width = "150px"}
</div>

and we save with *ctrl+o*, *ctrl+x*. We refresh the page in the browser, and we see that it's now working properly.

<div class="img_container">
![site working]({{https://jsom1.github.io/}}/_images/bpt1_working.png){: height="460px" width = "460px"}
</div>

Finally, we can click on Log In...

<div class="img_container">
![wp login working]({{https://jsom1.github.io/}}/_images/bpt1_wploginok.png){: height="320px" width = "320px"}
</div>

To be continued
